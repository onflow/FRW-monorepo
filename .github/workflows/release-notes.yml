name: Generate Release Notes

on:
  release:
    types: [published, created]

permissions:
  contents: write
  pull-requests: read

jobs:
  generate-release-notes:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Generate Release Notes
        id: release-notes
        run: |
          # Get the tag name from the release
          TAG_NAME="${{ github.event.release.tag_name }}"
          echo "Processing release: $TAG_NAME"

          # Get previous tag to find commit range
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 "$TAG_NAME^" 2>/dev/null || echo "")

          if [ -z "$PREVIOUS_TAG" ]; then
            echo "No previous tag found, using all commits from beginning"
            COMMIT_RANGE=""
          else
            echo "Previous tag: $PREVIOUS_TAG"
            COMMIT_RANGE="$PREVIOUS_TAG..$TAG_NAME"
          fi

          # Initialize release notes sections
          NEW_FEATURES=""
          IMPROVEMENTS=""
          BUG_FIXES=""
          BREAKING_CHANGES=""
          OTHER_CHANGES=""

          # Function to transform commit message to user-friendly format
          transform_message() {
            local commit_type="$1"
            local commit_scope="$2"
            local commit_description="$3"
            local commit_body="$4"
            
            # Use commit body if available, otherwise transform the description
            if [ -n "$commit_body" ] && [ "$commit_body" != "$commit_description" ]; then
              echo "- $commit_body"
            else
              case "$commit_type" in
                "feat"|"feature")
                  echo "- Added $commit_description"
                  ;;
                "fix")
                  echo "- Fixed $commit_description"
                  ;;
                "perf")
                  echo "- Improved performance of $commit_description"
                  ;;
                "refactor")
                  echo "- Refactored $commit_description for better maintainability"
                  ;;
                "style")
                  echo "- Updated styling for $commit_description"
                  ;;
                "docs")
                  echo "- Updated documentation for $commit_description"
                  ;;
                "test")
                  echo "- Added tests for $commit_description"
                  ;;
                "build"|"ci")
                  echo "- Improved build process and deployment"
                  ;;
                "chore")
                  echo "- Updated dependencies and maintenance tasks"
                  ;;
                *)
                  echo "- $commit_description"
                  ;;
              esac
            fi
          }

          # Process commits in the range
          if [ -z "$COMMIT_RANGE" ]; then
            COMMITS=$(git log --pretty=format:'%H|%s|%b' --no-merges)
          else
            COMMITS=$(git log --pretty=format:'%H|%s|%b' --no-merges "$COMMIT_RANGE")
          fi

          while IFS='|' read -r commit_hash commit_subject commit_body; do
            # Skip empty lines
            [ -z "$commit_hash" ] && continue
            
            # Parse conventional commit format
            if [[ $commit_subject =~ ^([a-zA-Z]+)(\([^)]+\))?(!)?:(.+)$ ]]; then
              commit_type="${BASH_REMATCH[1]}"
              commit_scope="${BASH_REMATCH[2]}"
              is_breaking="${BASH_REMATCH[3]}"
              commit_description="${BASH_REMATCH[4]}"
              
              # Clean up the description
              commit_description=$(echo "$commit_description" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
              
              # Transform the message
              transformed_message=$(transform_message "$commit_type" "$commit_scope" "$commit_description" "$commit_body")
              
              # Categorize the commit
              if [ -n "$is_breaking" ]; then
                BREAKING_CHANGES="$BREAKING_CHANGES$transformed_message"$'\n'
              elif [[ "$commit_type" == "feat" || "$commit_type" == "feature" ]]; then
                NEW_FEATURES="$NEW_FEATURES$transformed_message"$'\n'
              elif [[ "$commit_type" == "fix" ]]; then
                BUG_FIXES="$BUG_FIXES$transformed_message"$'\n'
              elif [[ "$commit_type" == "perf" || "$commit_type" == "refactor" || "$commit_type" == "style" ]]; then
                IMPROVEMENTS="$IMPROVEMENTS$transformed_message"$'\n'
              elif [[ "$commit_type" != "docs" && "$commit_type" != "test" && "$commit_type" != "chore" && "$commit_type" != "ci" && "$commit_type" != "build" ]]; then
                OTHER_CHANGES="$OTHER_CHANGES$transformed_message"$'\n'
              fi
            else
              # Handle non-conventional commits
              if [[ ! $commit_subject =~ ^(Merge|Revert) ]]; then
                OTHER_CHANGES="$OTHER_CHANGES- $commit_subject"$'\n'
              fi
            fi
          done <<< "$COMMITS"

          # Build the release notes
          RELEASE_NOTES=""

          if [ -n "$BREAKING_CHANGES" ]; then
            RELEASE_NOTES="$RELEASE_NOTES## üö® Breaking Changes"$'\n\n'"$BREAKING_CHANGES"$'\n'
          fi

          if [ -n "$NEW_FEATURES" ]; then
            RELEASE_NOTES="$RELEASE_NOTES## üÜï New Features"$'\n\n'"$NEW_FEATURES"$'\n'
          fi

          if [ -n "$IMPROVEMENTS" ]; then
            RELEASE_NOTES="$RELEASE_NOTES## üîß Improvements"$'\n\n'"$IMPROVEMENTS"$'\n'
          fi

          if [ -n "$BUG_FIXES" ]; then
            RELEASE_NOTES="$RELEASE_NOTES## üêõ Bug Fixes"$'\n\n'"$BUG_FIXES"$'\n'
          fi

          if [ -n "$OTHER_CHANGES" ]; then
            RELEASE_NOTES="$RELEASE_NOTES## üìù Other Changes"$'\n\n'"$OTHER_CHANGES"$'\n'
          fi

          # Add footer
          RELEASE_NOTES="$RELEASE_NOTES"$'\n'"---"$'\n\n'"**Full Changelog**: https://github.com/${{ github.repository }}/compare/$PREVIOUS_TAG...$TAG_NAME"

          # Handle case when no changes found
          if [ -z "$NEW_FEATURES$IMPROVEMENTS$BUG_FIXES$BREAKING_CHANGES$OTHER_CHANGES" ]; then
            RELEASE_NOTES="## What's Changed"$'\n\n'"No significant changes detected in this release."$'\n\n'"---"$'\n\n'"**Full Changelog**: https://github.com/${{ github.repository }}/compare/$PREVIOUS_TAG...$TAG_NAME"
          fi

          echo "Generated release notes:"
          echo "$RELEASE_NOTES"

          # Save to file for next step
          echo "$RELEASE_NOTES" > release_notes.md

          # Set output for GitHub API
          echo "RELEASE_NOTES<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Update Release Notes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Update the release with generated notes
          RELEASE_ID="${{ github.event.release.id }}"
          RELEASE_NOTES="${{ steps.release-notes.outputs.RELEASE_NOTES }}"

          # Escape quotes for JSON
          ESCAPED_NOTES=$(echo "$RELEASE_NOTES" | jq -Rs .)

          # Update release via GitHub API
          curl -L \
            -X PATCH \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID" \
            -d "{\"body\":$ESCAPED_NOTES}"

          echo "‚úÖ Release notes updated successfully!"

      - name: Add Release Notes Comment
        if: github.event.release.discussion_url
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üìù Release notes have been automatically generated and updated!"
